1. First Create an endpoint implementation class.

package endpoint;

import javax.jws.WebService;
import javax.jws.WebMethod;  

@WebService
public class Arithmetic {
	public Arithmetic() {}

	@WebMethod
	public int multiply(int a, int b) {
            int c = a * b ;
		return c;
	}
}

2. Compile the endpoint implementaion class and put in build folder - Use jar in C:\glassfish\lib  

3. Run wsgen tool to generate wsdl file

>wsgen -cp build -keep -d build -r build/wsgen -wsdl endpoint.Arithmetic

-cp (classpath): build folder
-r (with wsdl) : create wsdl file in build\wsgen
-wsdl          : provide endpont implemenation class
-keep          : keep generated files
The result of the above script is to create an ArithmeticService.wsdl file in
the build/wsgen directory. The name of the WSDL file is the same as the service name,
which you will recall defaults to the name of the endpoint implementation class
with "Service" appended. As well as the WSDL file, the associated XSD file,
ArithmeticService_Schema1.xsd, is also created.

4.a Java application web service is deployed as a class in a web
container. So after compiling the Java application we need to package it in a WAR file.
Put endpoint implementaion class in WEB-INF/classes folder.

jar -tvf arithmetic-webservice.war
0 Wed Apr 18 14:18:08 BST 2007 META-INF/
106 Wed Apr 18 14:18:06 BST 2007 META-INF/MANIFEST.MF
0 Wed Apr 18 14:16:18 BST 2007 WEB-INF/
0 Wed Apr 18 14:16:18 BST 2007 WEB-INF/classes/
0 Wed Apr 18 14:18:08 BST 2007 WEB-INF/classes/endpoint/
286 Wed Apr 18 14:18:08 BST 2007
WEB-INF/classes/endpoint/Arithmetic.class
>
We have named the WAR file arithmetic-webservice.war.

5.deploy war file

6.We can test our web service in glassfish admin UI

7.Now we have to develop a java client to invoke the service given the wsdl document.
This is done by generating stubs or proxies from the WSDL document. The proxy is the local
client representation of the remote web service.
The client then invokes the web service through the proxy.
GlassFish provides a tool, wsimport, for generating the proxies.
wsimport>-keep -d build/client http://localhost:8080/arithmetic-webservice/
ArithmeticService?WSDL

The final argument is the location of the WSDL file. This is the URL address of
the WSDL file suffixed with ?WSDL or ?wsdl.

package client;

import javax.xml.ws.WebServiceRef;
import endpoint.ArithmeticService;
import endpoint.Arithmetic;


public class WebServiceClient {
        
        @WebServiceRef(wsdlLocation="http://localhost:8080/arithmetic-webservice/ArithmeticService?WSDL")
        static ArithmeticService service;

        public static void main(String[] args) {
            try {
                int a = 3;
                int b = 4;
                Arithmetic port = service.getArithmeticPort();
                int result = port.multiply(3, 4);
                System.out.println("Result of multiplying " + a + " by " + b + " using webservice is: " + result);
            } catch(Exception e) {
                e.printStackTrace();
            }
       }

       
}

Note that we have imported endpoint.ArithmeticService and
endpoint.Arithmetic. These are proxy classes that were earlier generated by the wsimport tool. The package name, endpoint, 
is derived from the XML target namespace specified in the WSDL file.

The @WebServiceRef annotation is used to declare a reference to a web service. The web service is the generated ArithmeticService proxy.
We inject ArithmeticService into the service variable.

We next obtain a reference to a port using the ArithmeticService proxy getArithmeticPort() method. The port is another proxy, Arithmetic,
which implements the service endpoint interface. Finally we invoke the port's multiply operation.

WSDL:
The <portType> element describes the available web service operations:
<portType name="Arithmetic">
The name of a port type defaults to the service endpoint interface, or the service endpoint implementation class, if no interface has been provided.
The available web service operations are indicated by the <operation> element:
<operation name="multiply">
The name of an operation defaults to the Java method name.

The <service> Element
The WSDL service is indicated by the <service> element:
<service name="ArithmeticService">
<port name="ArithmeticPort"
binding="tns:ArithmeticPortBinding">
<soap:address location="http://localhost:8080/arithmetic-webservice/ ArithmmeticService"/>
</port>
</service>

The URL address is created at deploy time and takes one of two forms. If the web service is deployed in a web container, the URL takes the form:
http://<hostname>:<port>/context-root/<WSDL service name>

If the web service is deployed as a session bean in the EJB container we can dispense with context root in the URL address:
http://<hostname>:<port>/<WSDL service name>

The <message> and <types> Elements
The WSDL <message> element describes the parameters and return types of a web service message. The data types of these parameters and return types are specified in the WSDL <types> element:
<types>
<xsd:schema>
<xsd:import namespace="http://endpoint/"
schemaLocation="ArithmeticService_schema1.xsd"/>
</xsd:schema>
</types>

The second purpose of wsgen is to generate a number of Java classes required for marshalling and unmarshalling of method invocations, responses and exceptions during the execution of a web service. 
The actual marshalling and unmarshalling is performed by the container using the JAXB 2.0 API.

The Ant script to generate the artifacts is:
<target name="run-wsgen">
<mkdir dir="build/wsgen"/>
<exec executable="${glassfish.home}/bin/wsgen.bat"
failonerror="true" >
<arg line="-cp build -keep -d build
endpoint.Arithmetic"/>
</exec>
</target>
-keep specifies to keep the generated artifacts.
-d specifies where to place the generated artifacts. In our example this is the build directory. In fact, under the build directory wsgen will create the subdirectory endpoint/jaxws and place the artifacts in this subdirectory. The generated artifacts are actually source and compiled JavaBeans:
Multiply.class
Multiply.java
MultiplyResponse.class
MultiplyResponse.java

The Multiply JavaBean invokes the web service, and the MultiplyResponse JavaBean handles the response. If the endpoint implementation class contained exceptions then an additional JavaBean would be generated for each exception.




